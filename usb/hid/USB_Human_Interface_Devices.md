Original document: https://wiki.osdev.org/USB_Human_Interface_Devices 

The document was translated for personal use [@mikelpsv](https://github.com/mikelpsv)

## USB Human Interface Devices

`USB Human Interface Devices (HID)` это устройства, которые, как следует из названия, обеспечивают интерфейс для взаимодействия людей с компьютером, такие как: USB-мыши, USB-клавиатуры, USB-джойстики и другие подобные устройства.  Протокол, используемый устройствами USB HID, определен в спецификации. Некоторые наборы микросхем поддерживают эмуляцию USB-клавиатур и мышей как стандартных устройств PS/2. Таким образом, драйвер USB HID необходим на некоторых ПК, которые могут вообще не иметь портов PS/2.

### Протокол

Работа с устройствами USB HID, в основном, основаны на двух протоколах: протоколе отчетов и протоколе загрузки.
Отчет - это структура данных, которая отправляется на хост с устройства или наоборот. Когда устройство отправляет отчет на хост, он обычно содержит информацию об изменении состояния, такую как нажатие клавиши, движение мыши и т. д. Когда хост отправляет отчет на устройство, он обычно содержит команды для настройки устройства, такие как настройка светодиодов на клавиатуре, например. Этот протокол, конечно, зависит от [стандартной структуры USB](https://wiki.osdev.org/USB#USB_Device_Framework). Устройства USB HID используют прерывания, поскольку они не всегда передают данные, но когда они это делают, им требуется очень быстрый ответ от программного обеспечения, а передаваемые данные обычно имеют небольшой размер. Отчеты обычно бывают двух типов в зависимости от типа протокола. Протоколы отчетов основаны на концепции «элементов», а их структуры определяются в дескрипторах отчетов. Протокол загрузки намного проще и соответствует стандартным структурам для мышей и клавиатур. Для простоты в этой статье будет обсуждаться только протокол загрузки, по крайней мере, на данный момент.

##### Определение HID устройств

Устройства HID имеют в дескрипторе устройств значения Class/SubClass равными нулю, а действительные значения `Class/SubClass` указаны в дескрипторах интерфейса. Имейте в виду, что дескрипторы интерфейса не могут быть запрошены вручную и должны быть получены вместе с дескрипторами конфигурации и конечной точки. Значение `Class`, которое идентифицирует HID-устройство в интерфейсе, равно `3`. Значение SubClass в дескрипторе интерфейса может быть либо `1`, чтобы указать, что устройство поддерживает протокол загрузки, либо `0`, чтобы указать, что устройство поддерживает только протокол отчета. Поле `Protocol` в дескрипторе интерфейса также определяет мышь или клавиатуру. `1` указывает, что HID-устройство — это клавиатура, а `2` указывает, что HID-устройство — это мышь.

##### Запрос установки протокола "SetProtocol"

Предполагая, что устройство USB HID поддерживает протокол загрузки, как описано в разделе выше, со значениями `Class 3` и `SubClass 1`, драйвер может выбрать протокол для использования. Он использует запрос `SetProtocol`, чтобы сообщить устройству, хочет ли он использовать протокол отчета или протокол загрузки. Для простоты в этой статье пока описывается только протокол загрузки. Чтобы отправить запрос `SetProtocol`, драйвер отправляет обычную транзакцию SETUP в нулевую конечную точку управления устройством. Тип запроса пакета SETUP будет содержать `0x21`, код запроса для `SetProtocol` - `0x0B`, а поле значения пакета SETUP должно содержать `0` для указания протокола загрузки или `1` для указания протокола отчета. Поля индекса и длины должны быть нулевыми, так как индекс не используется и этот запрос не содержит этапов данных. Эта команда поддерживается только на устройствах, которые ?вообще поддерживают протокол загрузки?. После использования этой команды все отчеты, отправляемые с устройства на хост, будут либо отчетами о загрузке, либо обычными отчетами, в зависимости от типа запроса ПО.

##### Запрос отчета "GetReport"

ПО может запросить отчет с USB-устройства, используя конечную точку управления и обычный пакет SETUP. Тип запроса пакета SETUP будет содержать `0xA1`, код запроса для `GetReport` равен `1`, поле значение пакета SETUP будет содержать `0x0100`, чтобы запросить входной пакет с нулевым идентификатором, а поле длины будет длиной этапа данных, который хост хочет получить. Пакет SETUP должен быть отправлен на конечную точку устройства `0` (конечная точка управления). Для клавиатур этап данных обычно составляет 8 байтов, в то время как для мышей этап данных имеет первые 3 байта в стандартном формате, в то время как остальная часть может использоваться специфическими функциями устройства. Получение отчетов таким образом рекомендуется только для проверки успешного завершения инициализации устройства или чего-то подобного, а запрос `GetReport` не следует использовать для опроса HID-устройства на наличие изменений, поскольку этапы SETUP и STATUS тратят слишком много времени. Вместо этого ПО должно опрашивать HID, используя передачи прерывания, используя конечную точку прерывания `IN`.

##### Прерывание конечной точки

Обычно рекомендуется, чтобы HID отчитывался перед ПО, используя передачу с прерыванием, и это ПО обычно должно избегать запроса `GetReport`, упомянутого выше. ПО драйвера должно запрашивать дескриптор конфигурации для HID-устройства. HID-устройство должно поддерживать хотя бы одну конфигурацию. Затем программное обеспечение должно сканировать дескрипторы конечной точки в поисках дескриптора, указывающего на тип `interrupt IN`, который представляет собой конечную точку, которая отправляет данные устройства на хост с использованием передачи прерывания. ПО должно сохранять 4-битный идентификатор конечной точки, а также 8-битный интервал конечной точки. Значение интервала кодирует время в миллисекундах (мс), в течение которого программное обеспечение должно один раз опросить пакет отчета. Например, если значение интервала равно 8, программное обеспечение должно запрашивать отчет с устройства каждые 8 мс. Если программное обеспечение запрашивает отчет слишком рано, например, через 6 мс, устройство может отправить тот же пакет, что и раньше, или ничего не отправить, а вместо этого вернуть `NAK`. Если программное обеспечение запрашивает отчет по истечении промежутка времени, например, 9 мс, устройство отправит новый пакет. ПО постоянно опрашивает USB HID-устройства, используя описанный метод. Это также хороший шанс оптимизировать код USB, так как функции опроса будут выполняться сотни раз в секунду. В частности, в Bochs значение интервала для USB-мыши составляет 10 мс, поэтому программное обеспечение опрашивает USB-устройство 100 раз в секунду.

### USB клавиатура

Клавиатуры USB взаимодействуют с программным обеспечением с помощью отчетов, как и другие устройства HID. Клавиатуры USB определяются по коду `Class 3` и значению `Protocol 1` в дескрипторе интерфейса. Я буду описывать протокол загрузки здесь, для простоты, по крайней мере сейчас.

##### Формат отчета

Этот отчет должен запрашиваться программным обеспечением с помощью передачи прерываний один раз в миллисекунды, и интервал определяется в дескрипторе прерывания `IN` клавиатуры USB. Отчет USB-клавиатуры может иметь размер до 8 байт, хотя не все эти байты используются, и вполне нормально реализовать правильную реализацию, используя только первые три или четыре байта (и я так делаю). Просто для завершения, тем не менее, я опишу полный механизм доклада клавиатуры. Обратите внимание, что определенная ниже структура отчета применима только к протоколу загрузки.

| Смещение | Размер | Описание                        |
| -------- | ------ | ------------------------------- |
| 0        | Байт   | Сосотояние клавиш-модификаторов |
| 1        | Байт   | Зарезервировано                 |
| 2        | Байт   | Нажатие клавиши 1               |
| 3        | Байт   | Нажатие клавиши 2               |
| 4        | Байт   | Нажатие клавиши 3               |
| 5        | Байт   | Нажатие клавиши 4               |
| 6        | Байт   | Нажатие клавиши 5               |
| 7        | Байт   | Нажатие клавиши 6               |

`Сосотояние клавиш-модификаторов`: байт представляет собой битовое поле, где каждый бит соответствует определенному ключу-модификатору. Бит установленный в 1 соответсвует нажатию клавишы-модификатора. В отличие от клавиатур PS/2, USB-клавиатуры не имеют «скан-кодов» для клавиш-модификаторов. Битовая структура этого байта:

| Бит | Описание                       |
| --- | ------------------------------ |
| 0   | Left Ctrl                      |
| 1   | Left Shift                     |
| 2   | Left Alt                       |
| 3   | Left GUI (Windows/Super key.)  |
| 4   | Right Ctrl                     |
| 5   | Right Shift                    |
| 6   | Right Alt                      |
| 7   | Right GUI (Windows/Super key.) |

Когда ПО получает прерывание и, например, одна из клавиш-модификаторов Shift установлена на 1, программное обеспечение должно использовать таблицу скан-кодов для модификации сдвига, чтобы получить ключ из скан-кода.

`Зарезервировано`: Этот байт зарезервирован спецификацией USB HID, поэтому ПО должно его игнорировать.

`Нажатие клавиши`: Один отчет клавиатуры может указывать до 6 нажатий клавиш. Все эти значения представляют собой 8-битные значения без знака (в отличие от скан-кодов PS/2, которые в основном являются 7-битными), которые указывают на нажатую клавишу. Ссылка на таблицу преобразования скан-кодов USB в символы ASCII находится внизу статьи.

##### Механизм нажатия клавиш

Клавиатуры USB отправляют прерывания при нажатии или отпускании клавиши, как и клавиатура PS/2. Однако, в отличие от клавиатур PS/2, в клавиатуре USB нет понятия «создать» и «разбить» скан-коды. Когда пользователь нажимает клавишу, прерывание приходит со значением скан-кода в одном из полей нажатия клавиши. Когда клавиша отпущена, соответствующее поле нажатия клавиши возвращается в следующем пакете равным нулю. Чтобы проиллюстрировать это более четко и показать, почему существует более одного поля скан-кода нажатия клавиши, давайте рассмотрим следующие примеры.

Предположим, пользователь нажал клавишу `A`, которая имеет скан-код `0x04`. Возвращенный пакет прерывания будет выглядеть так:

```
 00 00 04 00 00 00 00 00
```

Обратите внимание, что клавиши-модификаторы равны нулю, потому что пользователь ничего не нажимает. Зарезервированное поле также равно нулю, как это рекомендовано спецификацией USB HID. Поле первого нажатия клавиши содержит `0x04`, что соответствует клавише `A`. Теперь предположим, что пользователь отпускает клавишу `А`. Отправленный пакет будет выглядеть так:

```
 00 00 00 00 00 00 00 00
```

Теперь предположим, что пользователь нажал клавишу `А`, а затем нажал клавишу `В` (скан-код `0x05`), не отпуская клавишу `А`:

```
 00 00 04 05 00 00 00 00
```

Обратите внимание, что один пакет прерывания может одновременно передавать два нажатия клавиш. Теперь предположим, что пользователь нажимает клавишу `C` (скан-код `0x06`), не отпуская ни клавиши `A`, ни `B`:

```
 00 00 04 05 06 00 00 00
```

А что, если пользователь отпустит клавишу `А`, но продолжит нажимать клавиши `В` и `С`? Клавиатура укажет, что `A` больше не нажимается, а `B` и `C` переместятся к началу пакета:

```
 00 00 05 06 00 00 00 00
```

USB-клавиатура возвращает скан-коды в том порядке, в котором они были нажаты первыми. Таким образом, если первое поле нажатия клавиши равно нулю, то больше нет других нажатых. А если оно не равно нулю, то ПО может проверить следующие поля, чтобы определить, не нажата ли другая клавиша.

Концепция клавиш-модификаторов вероятно очевидна, но для завершения предположим, что пользователь нажал левую клавишу `Shift` с клавишей `X` (скан-код `0x1B`). Отправленный пакет прерывания будет содержать:

```
 02 00 1B 00 00 00 00 00
```

Обратите внимание, что бит `1` (значение `0x02`) поля модификатора установлен, чтобы указать, что нажата левая клавиша `Shift`.

Существует также «фантомное состояние», о котором вы можете думать как о переполнении. Пакет USB-клавиатуры может указывать до 6 нажатий клавиш за одну передачу, но давайте представим, что кто-то уронил свою клавиатуру и за один раз было нажато более 6 клавиш. Клавиатура войдет в фантомное состояние, в котором все зарегистрированные клавиши будут иметь недопустимый скан-код `0x01`. Тем не менее, ключи-модификаторы по-прежнему будут сообщаться. Представьте, что нажимается 8 клавиш (или любое случайное число больше 6), а также нажимается правая клавиша `Shift`. Отправленный пакет будет выглядеть так:

```
 20 00 01 01 01 01 01 01
```

Обратите внимание, что клавиши-модификаторы по-прежнему отображаются, но все фактические скан-коды возвращают фантомное состояние. Помимо состояния фантома, существуют и другие специальные скан-коды: `0x00` указывает на отсутствие скан-кода и отсутствие нажатия клавиши, `0x01` указывает на фантомное состояние, которое мы только что объяснили, `0x02` указывает на сбой самопроверки клавиатуры, а `0x03` указывает на неопределенную ошибку. Начиная с `0x04` сканкоды действительны и соответствуют "настоящим" клавишам. ИМХО, драйвер устройства должен игнорировать фантомное состояние, если оно происходит.

##### Автоповтор

Одна неприятная вещь заключается в том, что в аппаратном обеспечении нет механизма автоматического повторения и задержки автоматического повторения; это должно быть полностью реализовано программно, в отличие от клавиатур PS/2. Например, задержка автоматического повторения 500 миллисекунд и скорость автоматического повторения 10 символов в секунду, когда программное обеспечение узнает, что определенная клавиша нажимается без постоянного отпускания, оно игнорирует все нажатия клавиш, кроме первого, в течение 500 секунд. миллисекунд (или любую другую задержку автоматического повтора, которая вам нравится), и если это время истекло, а клавиша все еще нажата, драйвер будет сообщать о 10 нажатиях клавиш каждую 1 секунду или любую другую скорость автоматического повторения, которую вы хотите. Это заставит пользователя чувствовать себя естественно, как будто вы нажимаете и удерживаете клавишу; на экране появляется первая клавиша, компьютер ждет небольшую задержку, а затем клавиши продолжают появляться.

##### LED индикаторы

Светодиодные индикаторы также обрабатываются программно, а `NumLock`, `CapsLock` и `ScrollLock` аппаратно - это обычные клавиши, которые отправляют обычные скан-коды. Драйвер отвечает за управление индикаторами при нажатии одной из этих клавиш.

Чтобы настроить индикаторы, драйвер отправляет на устройство запрос `SetReport`, используя стандартную транзакцию настройки USB с этапом данных в один байт. Тип запроса установочного пакета должен содержать `0x21`, код запроса для `SetReport`  `0x09`. Поле значения установочного пакета содержит идентификатор отчета в младшем байте, который должен быть равен нулю. Старший байт содержит тип отчета, который должен быть равен `0x02`, чтобы указать выходной отчет или отчет, который отправляется из программного обеспечения в аппаратное обеспечение. Поле индекса должно содержать номер интерфейса USB-клавиатуры, то есть номер, присутствующий в дескрипторе интерфейса, указывающий, что это устройство вообще является USB-клавиатурой. Стадия данных должна занимать 1 байт, то есть битовое поле. Эта транзакция настройки должна быть передана на нулевую конечную точку управления, которая будет работать на любом оборудовании. Другое оборудование может поддерживать или не поддерживать дополнительную конечную точку прерывания `OUT`. Если аппаратное обеспечение поддерживает конечную точку прерывания `OUT`, вы можете просто передать 1-байтовую стадию данных в конечную точку прерывания без дополнительных накладных расходов на этапы SETUP и STATUS. Если аппаратное обеспечение поддерживает конечную точку прерывания `OUT`, вам следует по возможности избегать конечной точки управления, так как конечная точка прерывания `OUT` быстрее и может быть запрограммирована с передачей прерывания вместо передачи настройки. Формат 1-байтового этапа данных (для транзакции SETUP) или 1-байтового прерывания передачи OUT показан ниже. Когда бит установлен в 1, включается соответствующий светодиод.

| Бит | Размер | Описание                                |
| --- | ------ | --------------------------------------- |
| 0   | 1      | Num Lock                                |
| 1   | 1      | Caps Lock                               |
| 2   | 1      | Scroll Lock                             |
| 3   | 1      | Compose                                 |
| 4   | 1      | Kana                                    |
| 5   | 3      | Зарезервировано. Должны быть равны нулю |

### USB мышь

USB мышь, как и любое другое устройство HID, взаимодействуют с ПО с помощью отчетов, которые отправляются через конечные точки прерывания или могут быть запрошены вручную с помощью запроса `GetReport`. Мыши USB имеют значение `Protocol 2` в дескрипторе интерфейса. 

##### Формат отчета

Этот отчет должен запрашиваться хостом с помощью передачи прерываний один раз в миллисекундный интервал. Интервал определяется в дескрипторе `IN` прерывания устройства USB-мыши. Определены только первые три байта отчета USB-мыши. Остальные байты, если они существуют, могут использоваться для функций, специфичных для устройства. Программное обеспечение может запросить только три байта в прерывании передачи, и это не вызовет ошибки, даже если фактический пакет больше. В таблице ниже указан формат отчета для USB-мышей, работающих с использованием загрузочного протокола.

| Смещение | Размер | Описание      |
| -------- | ------ | ------------- |
| 0        | Байт   | Статус кнопки |
| 1        | Байт   | движение по X |
| 2        | Байт   | движение по Y |

`Статус кнопки`: Этот байт представляет собой битовое поле, в котором младшие три бита имеют стандартный формат. Остальные 5 бит могут использоваться для конкретных целей устройства.

| Бит | Размер | Описание                                                                     |
| --- | ------ | ---------------------------------------------------------------------------- |
| 0   | 1      | Если установлено значение 1, это означает, что нажата `левая` кнопка мыши.   |
| 1   | 1      | Если установлено значение 1, это означает, что нажата `правая` кнопка мыши.  |
| 2   | 1      | Если установлено значение 1, это означает, что нажата `средняя` кнопка мыши. |
| 3   | 5      | Эти биты зарезервированы для конкретных функций устройства.                  |

`движение по X`: Это 8-битное целое число со знаком, представляющее движение по оси X. Бит 7 (значение 0x80) определяет знак значения. Когда это значение отрицательное, мышь перемещается влево. Когда это значение положительное, мышь перемещается вправо. Обратите внимание, что в отличие от мышей PS/2 значения перемещения для мышей USB представляют собой 8-битные целые числа со знаком, а не 9-битные целые числа.

`движение по Y`: Это также 8-битное целое число со знаком, которое представляет движение Y. Когда это значение отрицательное, мышь перемещается вверх. Когда значение положительное, мышь перемещается вниз (по направлению к пользователю).
