Original document: https://libusb.sourceforge.io/api-1.0/libusb_io.html

The document was translated for personal use [@mikelpsv](https://github.com/mikelpsv)



### Вступление

Если вы используете libusb в своем приложении, вы, вероятно, захотите выполнять операции ввода-вывод с устройствами - вы захотите выполнять передачу данных USB.

libusb предлагает два отдельных интерфейса для ввода/вывода устройств. На этой странице мы познакомим вас с ними, чтобы помочь вам решить, какой из них больше подходит для вашего приложения. Вы также можете использовать оба интерфейса в своем приложении, рассматривая каждую передачу в каждом конкретном случае.

После прочтения следующего обсуждения вам следует обратиться к страницам подробной документации API для получения подробной информации:

Синхронный ввод/вывод устройства: https://libusb.sourceforge.io/api-1.0/group__libusb__syncio.html
Асинхронный ввод/вывод устройства: https://libusb.sourceforge.io/api-1.0/group__libusb__asyncio.html

### Передача на логическом уровне

На логическом уровне передача данных через USB обычно состоит из двух частей. Например, при чтении данных из конечной точки:

1. Запрос данных отправляется на устройство

2. Некоторое время спустя входящие данные принимаются хостом

или при записи данных в конечную точку:

1. Данные отправляются на устройство

2. Через некоторое время хост получает подтверждение от устройства о том, что данные были переданы.

Между двумя шагами может быть неопределенная задержка. Рассмотрим вымышленное USB-устройство ввода с кнопкой, которую может нажать пользователь. Чтобы определить, когда кнопка нажата, вы, скорее всего, отправите запрос на чтение данных bulk или interrupt конечной точке и дождетесь поступления данных. Данные поступят, когда пользователь нажмет кнопку, что может произойти через несколько часов.

libusb предлагает как синхронный, так и асинхронный интерфейс для выполнения передачи USB. Основное отличие состоит в том, что синхронный интерфейс объединяет оба шага, указанные выше, в один вызов функции, тогда как асинхронный интерфейс разделяет их.

### Синхронный интерфейс

Синхронный интерфейс ввода-вывода позволяет выполнять передачу USB с помощью одного вызова функции. Когда вызов функции возвращается, передача завершена, и вы можете анализировать результаты.

Если вы раньше использовали libusb-0.1, этот стиль ввода-вывода покажется вам знакомым. libusb-0.1 предлагал только синхронный интерфейс.

В нашем примере с устройством ввода для чтения нажатий кнопок вы можете написать код в следующем стиле:

```c
unsigned char data[4];
int actual_length;
int r = libusb_bulk_transfer(dev_handle, LIBUSB_ENDPOINT_IN, data, sizeof(data), &actual_length, 0);
if (r == 0 && actual_length == sizeof(data)) {
    // results of the transaction can now be found in the data buffer
    // parse them here and report button press
} else {
    error();
}
```

Основным преимуществом этой модели является простота: вы делаете все одним простым вызовом функции.

Однако этот интерфейс имеет свои ограничения. Ваше приложение будет спать внутри `libusb_bulk_transfer()`, пока транзакция не завершится. Если пользователю требуется 3 часа, чтобы нажать кнопку, ваше приложение будет спать столько же  времени. Выполнение будет привязано к библиотеке — весь поток будет бесполезен на это время.

Другая проблема заключается в том, что, связывая поток с этой единственной транзакцией, невозможно одновременно выполнять ввод-вывод с несколькими конечными точками и/или несколькими устройствами, если только вы не прибегаете к созданию одного потока для каждой транзакции.

Кроме того, нет возможности отменить перевод после подачи заявки.

Дополнительные сведения об использовании синхронного API см. на страницах документации по синхронному API ввода-вывода: https://libusb.sourceforge.io/api-1.0/group__libusb__syncio.html

### Асинхронный интерфейс

Асинхронный ввод-вывод — самая важный новый функционал в libusb-1.0. Хотя это более сложный интерфейс, он решает все описанные выше проблемы.

Вместо того, чтобы указывать, какие функции блокируются до завершения ввода-вывода, асинхронный интерфейс libusb предоставляет неблокирующие функции, которые начинают передачу и затем немедленно возвращаются. Ваше приложение передает указатель функции обратного вызова этой неблокирующей функции, которую libusb вызовет с результатами транзакции после ее завершения.

Переводы, отправленные через неблокирующие функции, могут быть отменены отдельным вызовом функции.

Неблокирующий характер этого интерфейса позволяет одновременно выполнять ввод-вывод для нескольких конечных точек на нескольких устройствах без необходимости использования потоков.



Однако эта дополнительная гибкость сопряжена с некоторыми сложностями:

* В интересах легковесности библиотеки libusb не создает потоков и может работать только тогда, когда ваше приложение вызывает ее. Ваше приложение должно вызывать libusb из своего основного цикла, когда события готовы к обработке, или вы должны использовать какую-то другую схему, позволяющую libusb выполнять любую работу, которую ей необходимо.

* libusb также необходимо вызывать в определенные фиксированные моменты времени, чтобы точно обрабатывать тайм-ауты передачи.

* Работа с памятью становится более сложной. Вы не можете использовать стековую память, если функция с этим стеком не гарантированно не вернется до тех пор, пока не завершится выполнение обратного вызова передачи.

* Как правило, вы теряете некоторую линейность своего потока кода, потому что отправка запроса на передачу выполняется в отдельной функции, где обрабатываются результаты передачи. Это становится особенно очевидным, когда вы хотите отправить второй перевод на основе результатов предыдущего перевода.

Внутренне синхронный интерфейс libusb выражается в терминах вызовов функций асинхронного интерфейса.

Дополнительные сведения об использовании асинхронного API см. на страницах документации API асинхронного ввода-вывода: https://libusb.sourceforge.io/api-1.0/group__libusb__asyncio.html

