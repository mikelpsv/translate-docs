



Original document: https://libusb.sourceforge.io/api-1.0/group__libusb__dev.html 

The document was translated for personal use [@mikelpsv](https://github.com/mikelpsv)

## Подробное описание

Задокументированная ниже функциональность предназначена для помощи в следующих операциях:

Перечисление USB-устройств, подключенных в настоящее время к системе.
Выбор устройства для работы из вашего программного обеспечения.
Открытие и закрытие выбранного устройства.



## В двух словах...

Пример ниже действительно заставляет вещи казаться более сложными, чем они есть на самом деле. Следующая последовательность вызовов функций подойдет почти для всех сценариев и не требует от вас столь глубокого понимания вопросов управления ресурсами:

```c
// discover devices
libusb_device **list;
libusb_device *found = NULL;
ssize_t cnt = libusb_get_device_list(NULL, &list);
ssize_t i = 0;
int err = 0;
if (cnt < 0)
    error();
for (i = 0; i < cnt; i++) {
    libusb_device *device = list[i];
    if (is_interesting(device)) {
        found = device;
        break;
    }
}
if (found) {
    libusb_device_handle *handle;
    err = libusb_open(found, &handle);
    if (err)
        error();
    // etc
}
libusb_free_device_list(list, 1);
```

Два важных момента:

* Вы попросили `libusb_free_device_list()` освободить ссылки на устройства (2-й параметр)

* Вы открыли устройство перед освобождением списка и удалением ссылок на устройства.

Если вы получили дескриптор, теперь вы можете приступить к выполнению операций ввода-вывода на устройстве.



libusb имеет концепцию USB-устройства, представленного непрозрачным типом `libusb_device`. Устройство представляет собой USB-устройство, которое в настоящее время или ранее было подключено к системе. Используя ссылку на устройство, вы можете получить информацию об устройстве (например, вы можете прочитать данные дескриптора).

Функцию `libusb_get_device_list()` можно использовать для получения списка устройств, подключенных в данный момент к системе. Это называется обнаружением устройств.

Тот факт, что у вас есть ссылка на устройство, не означает, что его можно использовать. Возможно, устройство было отключено от сети, у вас может не быть разрешения на управление таким устройством, или устройство может использовать другая программа или драйвер.

Когда вы нашли устройство, которым хотели бы управлять, вы должны попросить libusb открыть устройство с помощью функции `libusb_open()`. В случае успеха libusb возвращает вам дескриптор устройства (`libusb_device_handle`). Все  операции ввода/вывода тогда работают с дескриптором, а не с исходным указателем устройства.



## Обнаружение устройств и подсчет ссылок

Обнаружение устройств, вызов `libusb_get_device_list()` возвращает актуальный список устройств на момент вызова. Сам список должен быть освобожден, когда вы закончите с ним. libusb также необходимо знать, когда можно освободить содержимое списка — самих устройств.

Для решения этих проблем libusb предоставляет вам два отдельных элемента:

* Функция для освобождения самого списка

* Система подсчета ссылок для устройств внутри

Все новые устройства, представленные функцией `libusb_get_device_list()`, имеют счетчик ссылок, равный 1. Вы можете увеличивать и уменьшать счетчик ссылок, используя `libusb_ref_device()` и `libusb_unref_device()`. Устройство уничтожается, когда его счетчик ссылок достигает 0.

С учетом вышеизложенной информации процесс открытия устройства можно представить следующим образом:

1. Обнаружение устройств с помощью `libusb_get_device_list()`.

2. Выбор устройства, для управления, и вызов `libusb_open()`.

3. Удаление ссылок на все устройства в списке обнаруженных.

4. Освобождение списка обнаруженных устройств.


Порядок важен — вы не должны удалять ссылку на устройство перед попыткой открыть его, потому что это может разрушить ??? устройство.

Для удобства функция `libusb_free_device_list()` включает параметр, позволяющий при необходимости отменить ссылки на все устройства в списке перед освобождением самого списка. Это объединяет шаги 3 и 4 выше.

В качестве детали реализации `libusb_open()` фактически добавляет ссылку на рассматриваемое устройство. Это связано с тем, что устройство остается доступным через дескриптор через `libusb_get_device()`. Ссылка удаляется во время `libusb_close()`.



### Типы

##### libusb_device

Структура, представляющая USB-устройство, обнаруженное в системе.

Это непрозрачный тип, для которого вам предоставляется только указатель, обычно происходящий из `libusb_get_device_list()` или `libusb_hotplug_register_callback()`.

Определенные операции могут выполняться на устройстве, но для выполнения каких-либо операций ввода-вывода вам необходимо сначала получить дескриптор устройства с помощью `libusb_open()`.

Ссылки на устройства подсчитываются с помощью `libusb_ref_device()` и `libusb_unref_device()` и освобождаются, когда счетчик ссылок достигает 0. Новые устройства, представленные `libusb_get_device_list()`, имеют счетчик ссылок, равный 1, и `libusb_free_device_list()` может дополнительно уменьшать счетчик ссылок на всех устройствах в списке. `libusb_open()` добавляет еще одну ссылку, которая позже уничтожается `libusb_close()`.

##### libusb_device_handle

Структура, представляющая дескриптор USB-устройства.

Это непрозрачный тип, для которого вам предоставляется только указатель, обычно исходящий из `libusb_open()`.

Дескриптор устройства используется для выполнения операций ввода-вывода и других операций. Закончив работу с дескриптором устройства, вы должны вызвать `libusb_close()`.



### Перечисления

##### libusb_speed

Коды скорости.

Указывает скорость, с которой работает устройство.

* `LIBUSB_SPEED_UNKNOWN`   ОС не сообщает и не знает скорость устройства.

* `LIBUSB_SPEED_LOW`  Устройство работает на низкой скорости (1.5MBit/s).

* `LIBUSB_SPEED_FULL`  Устройство работает на полной скорости (12MBit/s).

* `LIBUSB_SPEED_HIGH`  Устройство работает на высокой скорости (480MBit/s).

* `LIBUSB_SPEED_SUPER` Устройство работает на суперскорости (5000MBit/s).

* `LIBUSB_SPEED_SUPER_PLUS` Устройство работает на суперскорости плюс  (10000MBit/s).



### Функции

##### libusb_get_device_list

Возвращает список USB-устройств, подключенных в данный момент к системе. Возвращаемое значение этой функции указывает количество устройств в результирующем списке. Список на самом деле на один элемент больше, так как он завершается нулем.

##### libusb_free_device_list

Освобождает список устройств, полученных ранее с помощью `libusb_get_device_list()`.

Если параметр `unref_devices` установлен, счетчик ссылок каждого устройства в списке уменьшается на 1.

##### libusb_get_bus_number

Возвращает номер шины, к которой подключено устройство.

##### libusb_get_port_number

Возвращает номер порта, к которому подключено устройство.

Если операционная система не делает что-то странное или вы не подключаете карты расширения USB в горячем режиме, номер порта, возвращаемый этим вызовом, обычно гарантированно однозначно привязан к физическому порту, а это означает, что разные устройства, подключенные к одному и тому же физическому порту, должны возвращать одно и то же номер порта.

Но кроме этого, нет никакой гарантии, что номер порта, возвращаемый этим вызовом, останется прежним или даже будет соответствовать порядку, в котором порты были пронумерованы производителем HUB/HCD.

##### libusb_get_port_numbers

*Начиная с версии 1.0.16*

Возвращает список всех номеров портов от root для указанного устройства. В параметрах передается указатель на массив и его максимальную длину. Согласно спецификациям USB 3.0, текущий максимальный предел глубины составляет 7.

Возвращает количество заполненных элементов массива или LIBUSB_ERROR_OVERFLOW, если массив слишком мал

##### libusb_get_port_path

Устарело: вместо этого используйте `libusb_get_port_numbers()`.

##### libusb_get_parent

Возвращает родителя для указанного устройства.

Возвращает родительский элемент устройства или NULL, если он недоступен. Вы должны вызвать `libusb_get_device_list()` перед вызовом этой функции и убедиться, что вы обращаетесь только к родителю перед вызовом `libusb_free_device_list()`. Причина в том, что libusb в настоящее время не поддерживает постоянный список экземпляров устройств и, следовательно, может гарантировать только то, что родительские экземпляры полностью созданы в пределах блока `libusb_get_device_list()` - `libusb_free_device_list()`.

##### libusb_get_device_address

Возвращает адрес устройства на шине, к которой оно подключено.

##### libusb_get_device_speed

Возвращает согласованную скорость для устройства в виде кода `libusb_speed`.

##### libusb_get_max_packet_size

Удобная функция для получения значения `wMaxPacketSize` для конкретной конечной точки в конфигурации активного устройства.

Эта функция изначально предназначалась для помощи при настройке изохронных передач, но вместо этого возникла ошибка проектирования. Он просто возвращает значение `wMaxPacketSize` без учета его содержимого. Если вы имеете дело с изохронными передачами, вам, вероятно, понадобится `ibusb_get_max_iso_packet_size()`.

Возвращает значение `wMaxPacketSize` или `LIBUSB_ERROR_NOT_FOUND`, если конечная точка не существует и `LIBUSB_ERROR_OTHER` при другой ошибке

##### libusb_get_max_iso_packet_size

Возвращает максимальный размер пакета, который конкретная конечная точка может отправлять или получать в течение 1 микрофрейма.

Проверяется только активная конфигурация. Расчет основан на поле `wMaxPacketSize` в дескрипторе конечной точки, как описано в разделе 9.6.6 в спецификациях USB 2.0.

При работе с изохронной конечной точкой или точкой прерывания эта функция умножит значение, найденное в битах 0:10, на количество транзакций в микрофрейме (определяется битами 11:12). В противном случае эта функция просто вернет числовое значение, найденное в битах 0:10. Для устройства USB 3.0 он попытается получить дескриптор Endpoint Companion, чтобы вернуть `wBytesPerInterval`.

Эта функция полезна для настройки изохронных передач, например, вы можете передать возвращаемое значение из этой функции в `libusb_set_iso_packet_lengths()`, чтобы установить поле длины каждого изохронного пакета в передаче.

Начиная с версии 1.0.3.

Возвращает максимальный размер пакета, который может быть отправлен/получен на этой конечной точке, или `LIBUSB_ERROR_NOT_FOUND`, если конечная точка не существует, и `LIBUSB_ERROR_OTHER` в случае другой ошибки.

##### libusb_ref_device

Увеличивает счетчик ссылок устройства. Возвращает ссылку на устройство

##### libusb_unref_device

Уменьшает счетчик ссылок устройства. Если операция декремента приводит к тому, что счетчик ссылок достигает нуля, устройство должно быть уничтожено.

##### libusb_wrap_sys_device

Создает обертку дескриптора системного устройства для конкретной платформы и возвращает дескриптор устройства libusb для базового устройства.

Этот дескриптор позволяет вам использовать libusb для выполнения операций ввода-вывода на рассматриваемом устройстве.

Вызовите `libusb_set_option()` с параметрами (NULL, `LIBUSB_OPTION_NO_DEVICE_DISCOVERY`) перед `libusb_init()`, если вы хотите пропустить перечисление USB-устройств. В частности, это может понадобиться на Android, если у вас вообще нет прав доступа к USB-устройствам.

В Linux дескриптор системного устройства должен быть действительным файловым дескриптором, открытым на узле устройства.

Дескриптор системного устройства должен оставаться открытым, пока не будет вызвана `libusb_close()`. Дескриптор системного устройства не будет закрыт функцией `libusb_close()`.

Внутри эта функция создает временное устройство и делает его доступным для вас через `libusb_get_device()`. Это устройство уничтожается во время `libusb_close()`. Устройство нельзя открывать через libusb_open().

Это неблокирующая функция; никакие запросы не отправляются по шине.

Доступно с версии 1.0.23

Возвращает 0 в случае успешного вызова 
`LIBUSB_ERROR_NO_MEM` при сбое выделения памяти
`LIBUSB_ERROR_ACCESS`, если у пользователя недостаточно прав
`LIBUSB_ERROR_NOT_SUPPORTED`, если операция не поддерживается на этой платформе
другой код `LIBUSB_ERROR` при другом сбое

##### libusb_open

Открывает устройство и возвращает его дескриптор.

Дескриптор позволяет выполнять ввод-вывод на рассматриваемом устройстве.

Внутри эта функция добавляет ссылку на устройство и делает его доступным через `libusb_get_device()`. Эта ссылка удаляется во время `libusb_close()`.

Это неблокирующая функция; никакие запросы не отправляются по шине.

Возвращает 0 в случае успешного вызова
`LIBUSB_ERROR_NO_MEM` при сбое выделения памяти
`LIBUSB_ERROR_ACCESS`, если у пользователя недостаточно прав
`LIBUSB_ERROR_NO_DEVICE`, если устройство было отключено
код `LIBUSB_ERROR` при другом сбое

##### libusb_open_device_with_vid_pid

Удобная функция поиска устройства с определенной комбинацией `idVendor`/`idProduct`.

Эта функция предназначена для тех сценариев, где вы используете libusb для запуска быстрого тестового приложения — она позволяет вам избежать вызова `libusb_get_device_list()` и беспокойства о обходе/освобождении списка.

Эта функция имеет ограничения и, следовательно, не предназначена для использования в реальных приложениях: если несколько устройств имеют одинаковые идентификаторы, вы получите только первый и т. д.

Возвращает дескриптор устройства для первого найденного устройства или NULL в случае ошибки или если устройство не может быть найдено.

##### libusb_close

Закрывает дескриптор устройства.

Функция должна вызываться для всех открытых дескрипторов перед выходом из приложения.

Внутри эта функция уничтожает ссылку, которая была добавлена `libusb_open()` на данном устройстве.

Это неблокирующая функция; никакие запросы не отправляются по шине. 

##### libusb_get_device

Возвращает базовое устройство для дескриптора.

Эта функция не изменяет счетчик ссылок возвращаемого устройства, так что не требуется сбросить ссылку по завершению.

##### libusb_get_configuration

Определяет значение `bConfigurationValue` текущей активной конфигурации.

Вы можете сформулировать свой собственный управляющий запрос для получения этой информации, но эта функция имеет то преимущество, что она может извлекать информацию из кэшей операционной системы (без участия ввода-вывода).

Если ОС не кэширует эту информацию, эта функция будет заблокирована, пока выполняется передача управления для получения информации.

Эта функция вернет значение 0 в выходном параметре конфигурации, если устройство находится в ненастроенном состоянии.

Возвращает 0 в случае успешного вызова
LIBUSB_ERROR_NO_DEVICE если устройство было отключено
код `LIBUSB_ERROR` при другом сбое

##### libusb_set_configuration

Устанавливает активную конфигурацию для устройства.

Операционная система может уже установить или не установить активную конфигурацию на устройстве. Ваше приложение должно убедиться, что выбрана правильная конфигурация, прежде чем пытаться запрашивать интерфейсы и выполнять другие операции.

Если вы вызываете эту функцию на устройстве, уже сконфигурированном для выбранной конфигурацией, то эта функция будет действовать как облегченный сброс устройства: она выдаст запрос `SET_CONFIGURATION`, используя текущую конфигурацию, что приведет к сбросу большинства состояний устройства, связанных с USB (альтернативный сброс на ноль, остановка конечной точки очищается, переключатели сбрасываются).

Не все серверные части поддерживают установку конфигурации из пользовательского пространства, на что указывает код возврата `LIBUSB_ERROR_NOT_SUPPORTED`. Поскольку это предполагает, что платформа сама обрабатывает конфигурацию устройства, эту ошибку, как правило, можно безопасно игнорировать.

Вы не можете изменить/сбросить конфигурацию, если ваше приложение использует интерфейсы. Рекомендуется установить желаемую конфигурацию до утверждения интерфейсов.

В качестве альтернативы вы можете сначала вызвать `libusb_release_interface()`. Обратите внимание, что если вы делаете что-то таким образом, вы должны убедиться, что `auto_detach_kernel_driver` для `dev` равен 0, иначе драйвер ядра будет повторно подключен, когда вы освободите интерфейс(ы).

Вы не можете изменить/сбросить конфигурацию, если интерфейсы заявлены другими приложениями или драйверами.

Значение конфигурации -1 переводит устройство в ненастроенное состояние. В спецификациях USB указано, что для этого используется значение конфигурации 0, однако существуют устройства с ошибками, которые на самом деле имеют конфигурацию 0.

Вы всегда должны использовать эту функцию, а не формулировать свой собственный запрос управления `SET_CONFIGURATION`. Это связано с тем, что операционной системе необходимо знать, когда происходят такие изменения.

Это блокирующая функция.

Возвращает 0 в случае успешного вызова
`LIBUSB_ERROR_NOT_FOUND`, если запрошенная конфигурация не существует
`LIBUSB_ERROR_BUSY`, если в настоящее время заявлены интерфейсы
`LIBUSB_ERROR_NOT_SUPPORTED`, если настройка или изменение конфигурации не поддерживается серверной частью
`LIBUSB_ERROR_NO_DEVICE`, если устройство было отключено
код `LIBUSB_ERROR` при другом сбое

##### libusb_claim_interface

Заявляет интерфейс на данном дескрипторе устройства.

Вы должны заявить интерфейс, который хотите использовать, прежде чем сможете выполнять ввод-вывод на любой из его конечных точек.

Законно пытаться заявить права на уже заявленный интерфейс, и в этом случае libusb просто возвращает 0, ничего не делая.

Если для параметра `auto_detach_kernel_driver` установлено значение 1 для `dev`, при необходимости драйвер ядра будет отсоединен, в случае сбоя возвращается ошибка отсоединения.

Запрос интерфейсов — чисто логическая операция; это не приводит к отправке каких-либо запросов по шине. Утверждение интерфейса используется, чтобы указать операционной системе, что ваше приложение хочет стать владельцем интерфейса.

Это неблокирующая функция.

Возвращает 0 в случае успешного вызова
`LIBUSB_ERROR_NOT_FOUND` если заявленный интерфейс не существует
`LIBUSB_ERROR_BUSY` если другая программа или драйвер уже запросили интерфейс
`LIBUSB_ERROR_NO_DEVICE` если устройство было отключено
код `LIBUSB_ERROR` при другом сбое

##### libusb_release_interface

Освобождает ранее заявленный интерфейс с помощью `libusb_claim_interface()`

Вы должны освободить все заявленные интерфейсы перед закрытием дескриптора устройства.

Это блокирующая функция. На устройство будет отправлен запрос управления `SET_INTERFACE`, сбросив состояние интерфейса до первой альтернативной настройки.

Если для параметра `auto_detach_kernel_driver` установлено значение 1 для `dev`, драйвер ядра будет повторно подключен после освобождения интерфейса.

Возвращает 0 в случае успешного вызова
`LIBUSB_ERROR_NOT_FOUND` если заявленный интерфейс не существует
`LIBUSB_ERROR_NO_DEVICE` если устройство было отключено
код `LIBUSB_ERROR` при другом сбое

###### libusb_set_interface_alt_setting

Активация альтернативной настройки для интерфейса.

Интерфейс должен быть предварительно заявлен с помощью `libusb_claim_interface()`.

Вы всегда должны использовать эту функцию, а не формулировать свой собственный запрос управления `SET_INTERFACE`. Это связано с тем, что операционной системе необходимо знать, когда происходят такие изменения.

Это блокирующая функция.

Возвращает 0 в случае успешного вызова
`LIBUSB_ERROR_NOT_FOUND` если заявленный интерфейс не существует
`LIBUSB_ERROR_NO_DEVICE` если устройство было отключено
код `LIBUSB_ERROR` при другом сбое

##### libusb_clear_halt

Снимает условие остановки/задержки для конечной точки.

Конечные точки со статусом остановки не могут принимать или передавать данные, пока состояние остановки не будет установлено.

Вы должны отменить все ожидающие передачи, прежде чем пытаться снять состояние остановки.

Это блокирующая функция.

Возвращает 0 в случае успешного вызова
`LIBUSB_ERROR_NOT_FOUND` если заявленный интерфейс не существует
`LIBUSB_ERROR_NO_DEVICE` если устройство было отключено
код `LIBUSB_ERROR` при другом сбое

##### libusb_reset_device

Выполняет сброс USB-порта, чтобы повторно инициализировать устройство.

Система попытается восстановить предыдущую конфигурацию и альтернативные настройки после завершения сброса.

Если сброс не удался, дескрипторы изменились или предыдущее состояние не может быть восстановлено, устройство будет выглядеть как отключенное и повторно подключенное. Это означает, что дескриптор устройства больше недействителен (вы должны закрыть его) и повторно обнаружить устройство. Код возврата `LIBUSB_ERROR_NOT_FOUND` указывает на это.

Это блокирующая функция, которая обычно вызывает заметную задержку.

##### libusb_kernel_driver_active

Определяет, активен ли драйвер ядра на интерфейсе.

Если драйвер ядра активен, вы не можете заявить права на интерфейс, и libusb не сможет выполнять ввод-вывод.

Эта функция недоступна в Windows.

Возвращает
0, если драйвер ядра не активен
1, если драйвер ядра активен
`LIBUSB_ERROR_NO_DEVICE`, если устройство было отключено
`LIBUSB_ERROR_NOT_SUPPORTED` на платформах, где эта функция недоступна
код LIBUSB_ERROR при другом сбое

##### libusb_detach_kernel_driver

Отключает драйвер ядра от интерфейса.

В случае успеха вы сможете запросить интерфейс и выполнить ввод-вывод.

Эта функция недоступна в Windows.

Обратите внимание, что сам libusb также взаимодействует с устройством через специальный драйвер ядра, если этот драйвер уже подключен к устройству, этот вызов не отсоединит его и вернет `LIBUSB_ERROR_NOT_FOUND`.

Возвращает
0 при успешном вызове
`LIBUSB_ERROR_NOT_FOUND`, если драйвер ядра не был активен
`LIBUSB_ERROR_INVALID_PARAM`, если интерфейс не существует
`LIBUSB_ERROR_NO_DEVICE`, если устройство было отключено
`LIBUSB_ERROR_NOT_SUPPORTED` на платформах, где эта функция недоступна
код `LIBUSB_ERROR` при другом сбое

##### libusb_attach_kernel_driver

Повторно подключает драйвер ядра интерфейса, который ранее был отключен с помощью `libusb_detach_kernel_driver()`.

Эта функция недоступна в Windows.

Возвращает 0 при успешном вызове
`LIBUSB_ERROR_NOT_FOUND`, если драйвер ядра не был активен
`LIBUSB_ERROR_INVALID_PARAM`, если интерфейс не существует
`LIBUSB_ERROR_NO_DEVICE`, если устройство было отключено
`LIBUSB_ERROR_NOT_SUPPORTED` на платформах, где эта функция недоступна
`LIBUSB_ERROR_BUSY`, если драйвер не может быть подключен, потому что интерфейс занят программой или драйвером
код `LIBUSB_ERROR` при другом сбое

##### libusb_set_auto_detach_kernel_driver

Включает/отключает автоматическое отсоединение драйвера ядра libusb.

Когда это включено, libusb будет автоматически отсоединять драйвер ядра от интерфейса при запросе интерфейса и присоединять его при освобождении интерфейса.

Автоматическое отсоединение драйвера ядра отключено для вновь открытых дескрипторов устройств по умолчанию.

На платформах, на которых нет `LIBUSB_CAP_SUPPORTS_DETACH_KERNEL_DRIVER`, эта функция вернет `LIBUSB_ERROR_NOT_SUPPORTED`, и libusb продолжит работу, как если бы эта функция никогда не вызывалась.
